\section{Умножение чисел в формате с плавающей точкой}
\label{ch::float}

Для примеров будет использоваться формат с плавающей точкой, определенный в примере \ref{ch:digitFormat:16char} на странице \pageref{ch:digitFormat:16char}.

Результат произведения чисел, представленных в формате с плавающей точкой, $A=\FloatExpression{A}{2}$ и $B=\FloatExpression{B}{2}$ определяется как
\[
   A\cdot B= (\MantissOf{A}\cdot\MantissOf{B})\cdot 2^{(\OrderOf{A} + \OrderOf{B})}.
\]

Видно, что мантисса результата есть произведение соответствующих мантисс, а порядок --- сумма порядков операндов. В общем случае мантиса результата $(\MantissOf{A}\cdot\MantissOf{B})$ может оказаться денормализованной, и в процессе нормализации порядок результата будет скорректирован.

Алгоритм умножения (без возможных оптимизаций) чисел состоит из следующийх шагов:
\begin{enumerate}
   \item определяется результат перемножения мантисс по правилам умножения чисел с фиксированной точкой;
   \item определяется порядок результата суммированием порядков операндов по правилам сложения чисел с фиксированной точкой;
   \item выполняется нормализация мантиссы результата с соответствующими поправками порядка результата.
\end{enumerate}

Рассмотрим несколько примеров на формате с плавающей точкой (см. пример \ref{ch:digitFormat:16char} на странице \pageref{ch:digitFormat:16char}).

\begin{Example}
    Перемножить числа $A=-57$ и $B=11$ в формате с плавающей точкой.
\end{Example}
\begin{Solve}
    $-57 = (-111001)_2$, порядок $6$, характеристика $6+32=38=(100110)_2$. 
    
    $11 = (1011)_2$, порядок $4$, характеристика $36=(100100)_2$

    $A=-57$:
    \[
        \FloatMyCharHex{1}{111001000}{100110}
    \]
    
    $B=11$:
    \[
        \FloatMyCharHex{0}{101100000}{100100}
    \]

    Перемножая мантиссы (с масштабом $2^0$) получим дробный результат (также с масштабом $2^0$):
    \[
        \Number{,111001000}\cdot\Number{,101100000} = \Number{,100111001 100000000}.
    \]

    Как и положено, результат без потери точности будет представляться в $2n$ разрядной сетке, из которой в качестве результата придется взять $n$ старших разрядов результата\footnote{Здесь мы используем округление <<отсечением>>. О том как правильно следует округлять результат, рассказано в разделе \ref{ch::float::ss::round} на странице \pageref{ch::float::ss::round}}.

    Характеристику получим на основе следующих соображений. Характеристика $\Char$ из порядка $\Order$ получается следующим образом:
    \[
        \Char = \DC{\Order} + \Delta
    \]

    Тогда, складывая характеристики:
    \[
        \CharOf{A} + \CharOf{B} = 
            \DC{\OrderOf{A}} + \Delta + 
            \DC{\OrderOf{B}} + \Delta = 
                \underbrace{\DC{\OrderOf{A}} + \DC{\OrderOf{B}}}_{\DC{\OrderOf{A} + \OrderOf{B}}} + 2\Delta.
    \]

    Чтобы получить характеристику результата, очевидно из суммы характеристик нужно вычесть $\Delta$.
    
    Характеристика --- это положительное число. Увеличим разрядность для представления характеристики на два разряда, добавив их слева занеся в них нули (знак). После этого появляется возможность выполнять все поправки в дополнительном коде, и как только в добавочных разрядах окончательного результата возникнет комбинация, отличная от \Number{00} --- имеем ПРС. Фактически, в данном случае используется модифицированный дополнительный код (см. раздел \ref{ch:binadd}).

    Увеличиваем разрядность и находим сумму характеристик:
    \[
        \Addition{00100110}
                 {00100100}
                 {01001010}
    \]
    
    Выполняем поправку $(-\Delta=-32)$, получая характеристику результата:
    \[
        \Addition{01001010}
                 {11100000}
                 {00101010}
    \]

    В добавочных разрядах получается комбинация \Number{00} --- следовательно ПРС не возникло. Отбрасываем их и формируем результат:
    \[
        \FloatMyCharHex{1}{100111001}{101010}
    \]

    В формате представлено число $(-0.100111001)_2\cdot 2^{10} = (-1001110010)_2 = -626$. Правильный результат $-627$. Видно, что произошла (на практике совершенно неизбежная) потеря точности.
\end{Solve}

\begin{Example}
    Перемножить числа $A=0.5$ и $B=0.25$.
\end{Example}
\begin{Solve}

    $A=0.5$:
    \[
        \FloatMyCharHex{0}{100000000}{100000}
    \]
    
    $B=0.25$:
    \[
        \FloatMyCharHex{0}{100000000}{011111}
    \]
    
    После перемножения мантисс, результат получается ненормализованным: 
    \[
        \Number{,010000000 000000000}
    \]
    
    Нормализуем и отбрасываем младщую половину $2n$ разрядного результата: $\Number{,100000000}$. Мантисса была сдвинута влево, следовательно порядок (характеристику), нужно уменьшить на единицу.

    Увеличиваем разрядность и находим сумму характеристик:
    \[
        \Addition{00100000}
                 {00011111}
                 {00111111}
    \]
    
    Выполняем поправку $(-\Delta=-32)$, получая характеристику результата:
    \[
        \Addition{00111111}
                 {11100000}
                 {00011111}
    \]
    
    Уменьшаем характеристику на единицу (из-за ненормализованной мантиссы):
    \[
        \Addition{00011111}
                 {11111111}
                 {00011110}
    \]
    
    ПРС не возникло. Результат:
    \[
        \FloatMyCharHex{0}{100000000}{011110}
    \]
    
    $(0.100000000)_2\cdot 2^{-2} = 0.125$. Результат в данном случае получен без потерь в точности.
\end{Solve}

\begin{Example} 
    Перемножить числа
    \[
        \FloatMyCharHex{0}{100000000}{111100}\times
        \FloatMyCharHex{0}{100000000}{100100}
    \]
\end{Example}
\begin{Solve}
    Требуется перемножить числа $(0.5\cdot 2^{28})\cdot(0.5\cdot 2^{4})$.
    
    Мантисса результата ($2n$): $\Number{,010000000 000000000}$.
    
    Характеристика:
    \[
        \Addition{00111100}
                 {00100100}
                 {01100000}
    \]
    
    После поправки:
    \[
        \Addition{01100000}
                 {11100000}
                 {01000000}
    \]
    
    Получено ПРС характеристик! Однако в ходе нормализации мантиссы потребуется уменшение характеристики на единицу:
    \[
        \Addition{01000000}
                 {11111111}
                 {00111111}
    \]
    
    ПРС отсутствует! Результат верен:
    \[
        \FloatMyCharHex{0}{100000000}{111111}
    \]
    
    Балансируя на границе диапазона представления чисел, получили корректный результат $0.5\cdot 2^{31}$.
\end{Solve}

\begin{Example} 
    Перемножить числа
    \[
        \FloatMyCharHex{0}{100000000}{111000} \times
        \FloatMyCharHex{0}{100000000}{101111}
    \]
\end{Example}
\begin{Solve}
    Требуется перемножить числа $(0.5\cdot 2^{24})\cdot(0.5\cdot 2^{15})$.
    
    Мантисса результата ($2n$): $\Number{,010000000 000000000}$.
    
    Характеристика:
    \[
        \Addition{00111000}
                 {00101111}
                 {01100111}
    \]
    
    После поправки:
    \[
        \Addition{01100111}
                 {11100000}
                 {01000111}
    \]
    
    Получено ПРС характеристики! В ходе нормализации характеристика результата будет уменшена на единицу:
    \[
        \Addition{01000111}
                 {11111111}
                 {01000110}
    \]
    
    Но ПРС остается --- комбинация \Number{01} в добавочных разрядах. Полученный дополнительный код результата (с двумя добавочными разрядами) свидетельствует о том, что он положителен. В данном случае фиксируется ошибка вычислений ---  характеристика вышла за допустимую верхнюю границу представления.
\end{Solve}

\begin{Example} 
    Перемножить числа
    \[
        \FloatMyCharHex{0}{100000000}{001110} \times
        \FloatMyCharHex{0}{100000000}{001111}
    \]
\end{Example}
\begin{Solve}
    Требуется перемножить числа $(0.5\cdot 2^{-18})\cdot(0.5\cdot 2^{-17})$.
    
    Мантисса результата ($2n$): $\Number{,010000000 000000000}$.
    
    Характеристика:
    \[
        \Addition{00001110}
                 {00001111}
                 {00011101}
    \]
    
    После поправки:
    \[
        \Addition{00011101}
                 {11100000}
                 {11111101}
    \]
    
    Получено ПРС характеристики (в добавочных разрядах \Number{11})! Возможно, что ситуация изменится после вычитания единицы (из-за ненормализованной мантиссы):
    \[
        \Addition{11111101}
                 {11111111}
                 {11111100}
    \]
    
    Увы, ПРС остается --- в добавочном разряде единица. В данном случае имеем отрицательный результат. Это означает, что характеристика вышла за нижнюю границу представления. В данном случае ошибка вычислений не фиксируется. Получено очень малелнькое по модулю число, вместо которого можно вернуть ноль:
    
    \[
        \FloatMyCharHex{0}{000000000}{000000} \times
    \]
    
    В вычислительных устройствах такая ситуация отмечается, например установкой флага, который называется ПМР - потеря младших разрядов.
\end{Solve}


\section{Особенности округления чисел при умножении}
\label{ch::float::ss::round}

Допустим, что в некотором формате с плавающей запятой под мантиссу отводится $n$ разрядов. При перемножении мантисс, результат, как известно, получается разрядностью $2n$, а чтобы <<упаковать>> результат в формат, придётся отбросить половину\footnote{В случае дробной нормализации будет отброшена младшая половина $2n$-разрядной мантиссы результата. Что и предполагается в дальнейшем изложении} значащих разрядов, мирясь с неизбежными потерями в точности.

Один из самых простых вариантов --- округление <<отсечением>>: младшая половина разрядов отбрасывается, а старшая никак не изменяется.

С точки зрения увеличения точности, более корректным будет округление с учетом значений отбрасываемой половины. При перемножении чисел в прямых кодах особенных трудностей не возникает:
\begin{enumerate}
    \item результат нормализуется;
    \item младшая половина разрядов отбрасывается;
    \item если в старшем разряде отбрасываемой половины находится единица, то старшая <<оставшаяся>> половина результата инкрементируется;
    \item при необходимости выполняется нормализация.
\end{enumerate}

Для примеров возьмем все тот же формат.

\begin{Example}
    Перемножить числа $258$ и $381$.
\end{Example}
\begin{Solve}
    $258$:
    \[
        \FloatMyCharHex{0}{100000010}{101001}
    \]
    $381$:
    \[
        \FloatMyCharHex{0}{101111101}{101001}
    \]
    
    Результатом произведения мантисс будет
    \[
        \Number{,010111111 111111010}
    \]
    
    Полученный результат нормализуется (характеристика результата должна быть уменьшена на единицу):
    \[
        \Number{,101111111 111110100}
    \]
    
    И округляется:
    \[
        \Number{,110000000}
    \]

    Результат с корректным округлением $98304$:
    \[
        \FloatMyCharHex{0}{110000000}{110001}
    \]
    
    Результат без потерь в точности должен быть: $98298$. 
    
    Если использовать округление <<отсечением>>, то получившийся рузультат $98048$:
    \[
        \FloatMyCharHex{0}{101111111}{110001}
    \]
    будет куда менее точным.
\end{Solve}

Округление чисел, представленных в дополнительном коде\footnote{Ранее были рассмотрены методы умножения в дополнительных кодах}, имеет ряд особенностей. Если число положительное, то округление осуществляется так же, как в прямом коде. Если число отрицательное, то следует проанализировать несколько вариантов.

Допустим, что отрицательное число в дополнительном коде разделено на две части
\[
    \underbrace{1.xx\cdots xx}_A\underbrace{xx\cdots xx}_B,
\]
где $x$ --- обозначение произвольного значения двоичного разряда; часть $A$ --- старшие разряды дробного результата (целая часть представляет знак), а $B$ --- отбрасываемая часть.

\begin{itemize}
    \item Пусть $B=(10\cdots 0)$. Т.е. в отбрасываемой части старший разряд --- единица, а остальные --- нули. При извлечении модуля числа из дополнительного кода всего числа, проинвертируются все разряды части $A$, а в старшем разряде части $B$ останется единица. Т.е. модуль округленного результата должен быть инкрементирован: $|A| = \overline{A} + 1$. Каким он и будет являться, если часть $B$ просто отбросить.
    
    \item Пусть $B=(0\cdots 1\cdots)$. Т.е. в отбрасываемой части старший разряд --- ноль, а в остальных встречается хотя бы одна единица. Ситуация аналогична предыдущей: при извлечении модуля числа из дополнительного кода всего числа, проинвертируются все разряды части $A$, а в старшем разряде части $B$ возникнет единица. Т.е. модуль округленного результата должен быть инкрементирован: $|A| = \overline{A} + 1$. Каким он и будет являться, если часть $B$ просто отбросить.
    
    \item Пусть $B=(1\cdots 1\cdots)$. Т.е. в отбрасываемой части старший разряд --- единица, а в остальных встречается хотя бы одна единица. При извлечении модуля числа из дополнительлного кода всего числа, проинвертируются все разряды части $A$, а в старшем разряде части $B$ возникнет ноль. Инкрементировать модуль по правилам округления нет необходимости. Модуль округленного результата должен представлять собой $|A| = \overline{A}$, а если отбросить часть $B$, то он будет равен $(\overline{A} + 1)$. Следовательно, в этом случае часть $A$ нужно инкрементировать и отбросить часть $B$. Это следует из равенства $\overline{A}=\overline{(A + 1)} + 1$.
\end{itemize}

