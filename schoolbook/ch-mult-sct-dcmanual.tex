\subsection{Умножение в ДК с ручной коррекцией}

Если использовать дробное масштабирование и считать старший ($-1$-й) разряд дробной части знаковым, то дополнительный код дробного числа $A$:
\begin{equation}
    \DC{A} = 
    \begin{cases}
        |A|,      & \text{если $A$ положительно},\\
        1-|A|,    & \text{если $A$ отрицательно}.\\
    \end{cases}
    \label{eq:ch:mult:sct:dcmanual:dc}
\end{equation}

Если перемножить дополнительные коды чисел, то в зависимости от знаков операндов, может потребоваться коррекция результата.

Возможны следующие варианты сочетаний знаков сомножимых.
\begin{itemize}
    \item \emph{Оба сомножителя положительны}. Поправок не требуется.
    
    \item \emph{Один из сомножителей отрицателен}. Пусть $A$ --- отрицательно, $B$ --- положительно. Произведению дополнительных кодов будет соответствовать:
    \[
        (1-|A|)\cdot|B|=|B|-|A|\cdot|B|.
    \] 
    
    Чтобы получить корректный дополнительный код результата: $(1-|AB|)$, следует скорректировать полученный результат на величину $(1-|B|)$. То есть прибавить к результату $\DC{-B}=(1-|B|)$.
    
    \item \emph{Оба сомножителя отрицательны}. Результат произведения дополнительных кодов: 
    \[
        (1-|A|)(1-|B|)=1-|A|-|B|+|AB|
    \] 
    требует коррекции. Прибавив поправку $(|A|+|B|)$, получим $(1+|AB|)$, который вследствие переноса единицы в целую часть эквивалентен правильному $|AB|$.
\end{itemize}

\begin{Note}[Упрощенные правила коррекции]
    Правила ручной коррекции можно упростить: достаточно проверить знак каждого аргумента и, если этот аргумент отрицателен, то из суммы частичных произведений \emph{вычитается парный} отрицательному аргумент.
\end{Note}

В дополнительном коде знаковые разряды не приходится обрабатывать отдельно. Коррекцию, если она необходима, можно выполнить как до, так и после основного цикла умножения.

Умножение дополнительных кодов выполняется по правилам перемножения положительных чисел, так как, согласно формуле \eqref{eq:ch:mult:sct:dcmanual:dc} получающийся дополнительный код можно рассматривать как положительное дробное число. Поэтому основной цикл умножения можно выполнить по правилам перемножения модулей в прямом коде (см. раздел \ref{ch:mult:sct:pc}).

\begin{Example}\label{ex:binmul:dcmanualIoneof}
    Множитель $25=(11001)_2$, множимое $-23=(-10111)_2$. Перемножить числа в дополнительном коде с ручной коррекцией. Использовать I способ умножения.
\end{Example}
\begin{proof}[Решение]
    Чтобы правильно выбрать масштаб, достаточно вспомнить диапазон представления целых чисел в $n$-разрядном коде:
    \[
        [-2^{n-1},+(2^{n-1}-1)].
    \]

    Видно, что для наших чисел нужно $n=6$. Используем дробное масштабирование с $M=2^6$. При этом знаковым разрядом будет считаться старший разряд \emph{дробной} части. Тогда 
    \begin{align*}
        \DC{25\cdot 2^{-6}} =\Number{,011001},\\
        \DC{-23\cdot 2^{-6}}=1-0.010111=\underbrace{0.101001}_{\text{ДК } \equiv \text{ положит. число!}}=\Number{,101001}.
    \end{align*}

    Умножение дополнительных кодов как положительных чисел и последующая коррекция приводятся на рисунке \ref{fig:binmul:dcmanualIoneof}.
    
    Проверка результата: 
    \[\Number{,110111 000001}\Rightarrow(-.001000111111)_2\cdot 2^{12}\Rightarrow(-1000111111)_2=-575.\]
\end{proof}

\begin{figure}[!ht]
    \centering
    \begin{tabular}{c|r|l}
                                                                   \hline\hline
        мн-ль $\rightarrow$ 
                              & \multicolumn{1}{|c|}{СЧП $\rightarrow$}       
                                                           & прим. \\ \hline\hline
        \NumberLo{,01100}{1} & \Addition{.,000000 000000}
                                        {.,101001 ......}
                                        {.,101001 000000} & +мн-е ($\DC{-23}$); сдвиг\\ \hline
        \NumberLo{,.0110}{0} &   \Number{.,.10100 100000} & сдвиг\\ \hline
        \NumberLo{,..011}{0} &   \Number{.,..1010 010000} & сдвиг\\ \hline
        \NumberLo{,...01}{1} & \Addition{.,...101 001000}
                                        {.,101001 ......}
                                        {.,101110 001000} & +мн-е; сдвиг\\ \hline
        \NumberLo{,....0}{1} & \Addition{.,.10111 000100}
                                        {.,101001 ......}
                                        {1,000000 000100} & +мн-е; сдвиг\\ \hline
        \NumberLo{,....}{0} &    \Number{.,100000 000010} & сдвиг; \\ \hline
        \NumberLo{,....}{.} &    \Number{.,.10000 000001} & Рез-т на коррекцию!\\ \hline\hline
                             & \Addition{0,010000 000001}
                                        {.,100111 ......}
                                        {.,110111 000001} & поправка $+\DC{-0.011001}$\\ \hline
                             &   \Number{.,110111 000001} & Рез-т в ДК!\\
    \end{tabular}
    \caption{Умножение $\DC{25}\times \DC{-23}$ (I сп., к примеру \ref{ex:binmul:dcmanualIoneof})}
    \label{fig:binmul:dcmanualIoneof}
\end{figure}


\begin{Example}\label{ex:binmul:dcmanualIboth}
    Множитель $-25=(-11001)_2$, множимое $-23=(-10111)_2$. Перемножить числа в дополнительном коде с ручной коррекцией. Использовать I способ умножения.
\end{Example}
\begin{proof}[Решение]
    Используем дробное масштабирование с множителем $2^6$. Тогда 
    \begin{align*}
        \DC{-25\cdot 2^{-6}}=\Number{,100111},\\
        \DC{-23\cdot 2^{-6}}=\Number{,101001}.
    \end{align*}

    Умножение дополнительных кодов (как беззнаковых целых) и коррекция приведены на рисунке \ref{fig:binmul:dcmanualIboth}.
    
    Проверка результата: 
    \[\Number{,001000 111111}\Rightarrow(0.001000111111)_2\cdot 2^{12}\Rightarrow(1000111111)_2=575\]
\end{proof}

\begin{figure}[!ht]
    \centering
    \begin{tabular}{c|r|l}
        \hline\hline
        мн-ль $\rightarrow$ 
                             & \multicolumn{1}{|c|}{СЧП $\rightarrow$}       
                                                        & прим. \\ \hline\hline
        \NumberLo{.,10011}{1} & \Addition{.,000000 000000}
                                         {.,101001 ......}
                                         {.,101001 000000} & +мн-е; сдвиг\\ \hline
        \NumberLo{.,.1001}{1} & \Addition{.,.10100 100000}
                                         {.,101001 ......}
                                         {.,111101 100000} & +мн-е; сдвиг\\ \hline
        \NumberLo{.,..100}{1} & \Addition{.,.11110 110000}
                                         {.,101001 ......}
                                         {1,000111 110000} & +мн-е; сдвиг\\ \hline
        \NumberLo{.,...10}{0} &   \Number{.,100011 111000} & сдвиг\\ \hline
        \NumberLo{.,....1}{0} &   \Number{.,.10001 111100} & сдвиг\\ \hline
        \NumberLo{.,.....}{1} & \Addition{.,..1000 111110}
                                         {.,101001 ......}
                                         {.,110001 111110} & +мн-е; сдвиг\\ \hline
        \NumberLo{.,.....}{.} &   \Number{.,.11000 111111} & Р-т на коррекцию!\\ \hline\hline
                              & \Addition{.,.11000 111111}
                                         {.,011001 ......}
                                         {.,110001 111111} & поправка $+\DC{0.011001}$\\ \hline
                              & \Addition{.,110001 111111}
                                         {.,010111 ......}
                                         {1,001000 111111} & поправка $+\DC{0.010111}$\\ \hline
                              &   \Number{.,001000 111111} & Рез-т в ДК!\\
    \end{tabular}
    \caption{Умножение $\DC{-25}\times \DC{-23}$ (I сп., к примеру \ref{ex:binmul:dcmanualIboth})}
    \label{fig:binmul:dcmanualIboth}
\end{figure}

С технической точки зрения, каждый способ умножения(см. рис. \ref{fig:binmul:baseschemes}) накладывает свои ограничения на коррекцию.
\begin{itemize}
    \item I-й способ. Так как регистр СЧП сдвиговый и модифицируется только его старшая часть, то верные поправки возможно выполнить только в конце цикла умножения. Вклад поправок, сделанных в начале цикла, с каждым сдвигом будет уменьшаться вдвое. Так как множитель в течение цикла сдвигается, то его значение нужно сохранить, чтобы в конце цикла использвоать для коррекции.
    
    Так как на каждом шаге умножения нужно прибавлять множимое, деленное на 2 (сдвинутое на 1 разряд вправо), а коррекцию в ряде случаев выполнять множимым, то можно на каждом шаге умножения прибавлять не сдвинутое множимое, но делать сдвиг всей суммы на последнем шаге.
    
    \item II-й способ. Так как регистр СЧП не сдвиговый, то поправку множителем лучше сделать в начале цикла. Если множитель сохранить, то поправку можно выполнить в любое время. Поправку множимым можно сделать только в конце цикла, когда, после серии сдвигов, разряды регистра множимого будут содержать правильное значение.

    \item III-й с способ. Поправку множимым лучше всего сделать в начале цикла умножения, так как в этом случае исходный вклад 
    \[
        \texttt{множимое}\cdot 2^{-n}
    \]
    в сумму частичных произведений к концу цикла будет правильным (до первого шаго умножения обязательно выполняется сдвиг СЧП). Поправку множителем можно сделать либо в начале цикла, сдвинутым значением 
    \[
        \texttt{множитель}\cdot 2^{-n},
    \]
    либо в конце цикла (позаботившись о сохранении множителя).
    
    \item IV-й способ. Поправку множимим логично сделать в начале цикла умножения, до его первого сдвига. Поправку множителем можно сделать в начале или в любой другой момент, позаботившись о его сохранении.
\end{itemize}  