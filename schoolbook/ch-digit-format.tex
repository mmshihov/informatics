\chapter{Представление чисел}
\label{ch:digitFormat}

Число в двоичном вычислительном устройстве будет представлено последовательностью двоичных разрядов (бит). Длина этой последовательности фиксирована и обычно кратна байту\footnote{В большинстве случаев байт --- это 8 бит. В общем случае байтом называется блок бит, адресуемый как одно целое в адресном пространстве компьютера, --- это не всегда 8 бит! Далее мы будем считать, что байт --- это 8 бит, хотя когда вы имеете в виду именно 8 бит, то правильно говорить, как это всегда делают французы, --- октет}. Пусть длина этой последовательности $n$-бит.

Задача сводится к тому, чтобы $n$-разрядной двоичной последовательностью \emph{закодировать} (представить) вещественное число. Чтобы научиться грамотно это делать, следует усвоить:

\begin{itemize}
    \item правила сложения беззнаковых целых чисел;
    \item коды для представления целых чисел;
    \item форматы для представления вещественных чисел.
\end{itemize}

Последовательность длиной $n$ кодовых символов будем называть $n$-разрядной сеткой, а нумеровать разряды будем с нуля, справа-налево:
\[
    \UnsignedAny{n-1}{xxxxx...xxxxx}
\]


\section{Правила сложения беззнаковых целых чисел}

Сложение беззнаковых целых\footnote{Можно было сказать и натуральных, но натуральные числа это: $\mathbb{N}=\{1,2,3,\ldots\}$, натуральное множество с нулем назвается расширенным натуральным множеством  $\mathbb{N}_0=\{0,1,2,\ldots\}$} $n$-разрядных чисел $A$ и $B$, представленных в системе счисления по основанию $k$:

\begin{align*}
    A=&(a_{n-1}\cdots a_0)_k,\\
    B=&(b_{n-1}\cdots b_0)_k,
\end{align*}

выполняется поразрядно от младшего разряда к старшему. Для каждого $i$-го разряда вычисляется сумма
\begin{equation}    
    \label{eq:digitFormat:sum}
    s_i = a_i + b_i + c_i,
\end{equation}
где $a_i,b_i$ --- цифры в $i$-м разряде исходных операндов $A,B$; $c_i$ --- перенос (1 или 0) из $(i-1)$-го разряда.

Процесс начинается с нулевого разряда, при этом перенос в нулевой разряд полагается равным нолю $c_0=0$. Цифры результата $R=(A+B)$ определяются последовательно слева-направо: $r_0,r_1,r_2\ldots$. $i$-я цифра результата определяется по правилу:
\begin{equation}    
    \label{eq:digitFormat:sumDigit}
    r_i = 
        \begin{cases}
            s_i,     &\text{ если $s_i<k$},\\
            (s_i-k), &\text{ если $s_i\ge k$},
        \end{cases}
\end{equation}
где $s_i$ --- сумма цифр и переноса из предыдущего разряда (формула \eqref{eq:digitFormat:sum}), а $k$ --- основание системы счисления.

Перенос из $i$-го разряда в следующий разряд получается по правилу:
\begin{equation}    
    \label{eq:digitFormat:sumCrp}
    c_{i+1} =         
        \begin{cases}
            0, &\text{ если $s_i<k$},\\
            1, &\text{ если $s_i\ge k$}.
        \end{cases}
\end{equation}

Таблица сложения для двоичной системы:
\[
    \begin{tabular}{ccccc|cc}
        \hline\hline
        $a_{i}$ 
          &$+$
              & $b_{i}$ 
                  &$+$
                      & $c_{i}$ 
                          & $c_{i+1}$
                              &  $r_i$ 
                                    \\
        \hline\hline
        0 &   & 0 &   & 0 & 0 & 0 \\
        0 &   & 1 &   & 0 & 0 & 1 \\
        1 &   & 0 &   & 0 & 0 & 1 \\
        1 &   & 1 &   & 0 & 1 & 0 \\
        0 &   & 0 &   & 1 & 0 & 1 \\
        0 &   & 1 &   & 1 & 1 & 0 \\
        1 &   & 0 &   & 1 & 1 & 0 \\
        1 &   & 1 &   & 1 & 1 & 1 \\
        \hline
    \end{tabular}
\]

\begin{Example}
    Сложить двоичные числа:
    $A=(101110100)_2$ и
    $B=(011010111)_2$.
\end{Example}
\begin{proof}[Решение]
    \[
        {\entrymodifiers={}
            {\xymatrix@=1pc{
                A&=
                    &   &1  &0  &1  &1  &1  &0  &1  &0  &0 \\
                B&=
                    &   &0  &1  &1  &0  &1  &0  &1  &1  &1\\
                c_i
                &  
                    &\text{\small{1}}
                        &\text{\small{1}}
                            &\text{\small{1}}
                                &\text{\small{1}}
                                    &\text{\small{1}}
                                        & 
                                            &\text{\small{1}}
                                                & 
                                                    & 
                                                        & \\                    
                R=A+B
                &=
                    &1
                        &0\ar[ul]
                            &0\ar[ul]
                                &1\ar[ul]
                                    &0\ar[ul]
                                        &0\ar[ul]
                                            &1
                                                &0\ar[ul]
                                                    &1
                                                        &1
            }}
        }
    \]
    
    Нулевые переносы, не меняющие результат сложения, на рисунке не показаны.
\end{proof}

Операция вычитания заменяется сложением с обратным элементом: 
\[A-B = A+(-B).\]

\section{Коды для представления целых чисел}

Целое число может быть как положительным, так и отрицательным. На практике сложилось несколько кодов для представления целых чисел в $n$-разрядной сетке: прямой, дополнительный и обратный.


\subsection{Прямой код}

Самый старший разряд $n$-разрядной сетки прямого кода хранит знак числа и называется \emph{знаковым}. Знаковый разряд содержит единицу, если число отрицательное, и нуль --- в противном случае. Можно сказать, что знак \emph{минус} кодируется единицей, а \emph{плюс} --- нулем.

Для представления модуля числа остается $(n-1)$ разрядов сетки. В этих разрядах можно закодировать значения модуля от $0$ до $(2^{n-1}-1)$. Следовательно, в прямом коде можно представить целые числа из отрезка
\[
    \left[-(2^{n-1}-1), +(2^{n-1}-1)\right].
\]

Например, в $8$-разрядной сетке:
\begin{itemize}
    \item \SignedByte{0}{0000101} $\Leftrightarrow$ $5$;
    \item \SignedByte{1}{0000101} $\Leftrightarrow$ $-5$;
    \item \SignedByte{0}{1111111} $\Leftrightarrow$ максимум в 8-разрядной сетке: $127$;
    \item \SignedByte{1}{1111111} $\Leftrightarrow$ минимум в 8-разрядной сетке: $-127$;
    \item \SignedByte{0}{0000000} $\Leftrightarrow$ $0$;
    \item \SignedByte{1}{0000000} $\Leftrightarrow$ запрещенный здравым смыслом ${-0}$;
\end{itemize}

Как видно из примеров, в прямом коде число ноль может быть представлено двумя различными кодовыми словами. 

Прямой код удобен только для представления чисел, а для выполнения операций сложения и вычитания представляемых чисел на практике приходится переходить от прямого к дополнительному, либо к обратному кодам.


\subsection{Дополнительный код}

В подавляющем большинстве процессоров и микроконтроллеров целые числа представляются в \emph{дополнительном} коде. 

Положительное число представляется в дополнительном коде естественным образом. Отрицательное число $A$ представляется как результат вычитания из нуля модуля этого числа: $(0-|A|)$.

Если к максимальному числу $(2^{n}-1)$ из отрезка прибавить единицу, то возникнет перенос в отсутствующий в разрядной сетке $n$-й разряд. Этот перенос будет успешно потерян и результом будет \emph{ноль}:
\[
    \underbrace{11\cdots 11}_n + 1 = \underbrace{00\cdots 00}_n = 0.
\]
 
В конечной $n$-разрядной сетке число $2^n$ просто \emph{невозможно} представить, но удобно считать, что $2^n\equiv 0$. Тогда представление отрицательного числа $A$:
\[
    0-|A| = 2^n - |A| = (2^n - 1) - |A| + 1 = (\underbrace{11\cdots 11}_n - |A|) + 1 = \overline{|A|}+1.
\]

Разность $(\underbrace{11\cdots 11}_n - |A|)$ представляет собой \emph{инверсию} разрядов $|A|$, т.е. $\overline{|A|}$.
 
Дополнительный код числа $A$ будем обозначать $\DC{A}$.
\[
    \DC{A}=
    \begin{cases}
        \overline{|A|}+1, &\text{если $A<0$},\\
        |A|,              &\text{если $A\geq 0$}.
    \end{cases}
\]

Дополнительный код положительного числа совпадает с двоичным представлением его модуля. Дополнительный код отрицательного числа получается в результате инверсии разрядов представления модуля с последующим прибавлением единицы.

Используя дополнительный код, в $n$-разрядной сетке можно представить числа из отрезка 
\begin{equation}
    \label{eq:digitFormat:dcDiapazone}
    \left[-2^{n-1}, (2^{n-1} - 1)\right].
\end{equation}

\begin{Example}
    Некоторые характерные дополнительные коды чисел в $n$-разрядной сетке 
    \begin{itemize}
        \item $\DC{-1}=\underbrace{11\cdots 11}_n$
        \item $\DC{-2^{n-1}}=\underbrace{10\cdots 00}_n$
        \item $\DC{2^{n-1}-1}=\underbrace{01\cdots 11}_n$
        \item $\DC{-2}=\underbrace{11\cdots 10}_n$
        \item $\DC{0}=\underbrace{00\cdots 00}_n$
        \item $\DC{1}=\underbrace{00\cdots 01}_n$
    \end{itemize}
\end{Example}

Например, в $8$-разрядной сетке:
\begin{itemize}
    \item \SignedByte{0}{0001010} $\Leftrightarrow$ $10$;
    \item \SignedByte{1}{1110110} $\Leftrightarrow$ ${-10}$;
    \item \SignedByte{0}{1111111} $\Leftrightarrow$ максимум в 8-разрядной сетке: $127$;
    \item \SignedByte{1}{0000000} $\Leftrightarrow$ минимум в 8-разрядной сетке: $-128$;
    \item \SignedByte{0}{0000000} $\Leftrightarrow$ $0$;
    \item \SignedByte{1}{1111111} $\Leftrightarrow$ ${-1}$;
\end{itemize}

\begin{Example}
    Найти дополнительный код числа $-57$ в восьми-разрядной сетке.
\end{Example}
\begin{Solve}
    $|{-57}|=(111001)_2$. В разрядной сетке $|{-57}|$ будет представлено следующим образом:
    \[\UnsignedByte{00111001}\]
    $\DC{-57}$, соответственно равен $(\overline{\Number{00111001}} + \Number{1})$ или $(\Number{11000110} + \Number{1})$:
    \[\UnsignedByte{11000111}\]
    
    Сокращенное правило нахождения дополнительного кода заключается в инвертировании всех разрядов числа, начиная со старшего, за исключением самой младшей единицы. Например, 
    \[\DC{-52}=\overline{\Number{00110100}} + \Number{1} = \overline{\Number{00110}}\Number{100} = \Number{11001100}.\]
    
    Так получается потому, что после прибавления единицы к инверсии разрядов модуля:
    \[\Number{110010}\underline{\Number{11}} + \Number{1}\]
    перенос распространяется через младшую группу получившихся после инверсии единиц, <<оседая>> на месте самой младшей единицы в представлении модуля.
\end{Solve}

При этом о знаке числа, представленного в дополнительном коде удобно судить по старшему разряду кода\footnote{В литературе часто могут встретится обозначения: msb --- most significant bit (старший значащий бит); lsb --- less significant bit (младший значащий бит)}: если он равен единице, то число отрицательно, а в противном случае --- положительно. Старший разряд обычно называют \emph{знаковым} и выделяют в разрядной сетке особо. Например, $\DC{-52}$ в восьми-разрядной сетке:
\[
    \FixedByte{1}{1001100}
\]

Исходя из выкладок:
\begin{align*}
    \DC{A}=(2^n-1)-|A|+1, \\
    |A|=(2^n-1)-\DC{A}+1, \\
    |A|=\overline{\DC{A}}+1,
\end{align*}
модуль отрицательного двоичного числа из представления в дополнительном коде извлекается теми же действиями:
\[
    |A|=
    \begin{cases}
        \overline{\DC{A}}+1, &\text{если в знаковом разряде кода 1, т.е. $msb(\DC{A})=1$}, \\
        \DC{A},              &\text{если в знаковом разряде кода 0, т.е. $msb(\DC{A})=0$}.
    \end{cases}
\]

\begin{Note}[Сумма кодов]
    При суммировании дополнительных кодов операндов получается дополнительный код результата. 
\end{Note}

\begin{Example}
    Выполнить вычитание $(52-57)$ в двоичной системе счисления в дополнительном коде.
\end{Example}
\begin{Solve}
    После сложения дополнительных кодов $(\DC{52} + \DC{-57})$ получается дополнительный код результата:
    \[
        \Addition{00110100}{11000111}{11111011}
    \]
    Так как $msb(\Number{11111011})=1$, то представленное в дополнительном коде число --- отрицательное. Модуль этого числа:
    
    \[|X|=\overline{\Number{11111011}} + \Number{1} = \overline{\Number{1111101}}\Number{1} = \Number{00000101}.\]
    
    Следовательно, результатом является число $-5$.
\end{Solve}

\begin{Example}
    Выполнить вычитание $(57-52)$ в двоичной системе счисления в дополнительном коде.
\end{Example}
\begin{Solve}
    \[
        \Addition{00111001}{11001100}{00000101}
    \]
    
    Так как $msb(\Number{00000101})=0$, то в дополнительном коде представлено $+5$.
\end{Solve}

В ряде случаев, результат сложения дополнительных кодов может получиться неправильным. Такая ситуация называется \emph{переполнением разрядной сетки} (ПРС) и возникает, когда результат не может быть представлен в $n$ разрядах сетки. Если исходные операнды представимы в $n$ разрядах, то есть принадлежат отрезку $\left[-2^{n-1}, 2^{n-1} - 1\right]$, то ПРС может возникнуть только в том случае, когда операдны имеют одинаковый знак.

\begin{Note}[Переполнение разрядной сетки]
    ПРС возникает, если складывались операдны одного знака, а результат получился противоположного знака.
\end{Note}

\begin{Example}
    В $8$-разрядной сетке найти результат сложения $85+93$.
\end{Example}
\begin{Solve}
    Согласно формуле \eqref{eq:digitFormat:dcDiapazone} в $8$-разрядной сетке представимы числа из отрезка $[-128,127]$. Сложение дополнительных кодов дает:
    \[
        \Addition{01010101}{01011101}{10110010}
    \]
    
    Результат в разрядную сетку не умещается и, если не отследить ПРС, то можно зафиксировать неправильный результат: $-78$.
    
    Например, та же самая ситуация, но для отрицательных чисел $(-85)+(-93)$:
    \[
        \Addition{10101011}{10100011}{01001110}
    \]
    
    Не отследив ПРС, можно получить неправильный результат: $+78$.
\end{Solve}

Видно, что для того, чтобы представить результат --- достаточно увеличить сетку на один разряд. Это можно использовать для контроля на ПРС: взять на время вычисления разрядность <<с запасом>>. Так и поступают в \emph{модифицированном} дополнительном коде, в котором для представления знака используется два разряда, а не один.

\begin{Note}[Модифицированный дополнительный код (МДК)]
    МДК получается из исходного $n$-разрядного ДК добавлением слева разряда, дублирющего знаковый. При сложении $(n+1)$-разрядных МДК, проверяется старшая пара разрядов (знак) результата: если комбинация отличается от $\Number{00}$ и $\Number{11}$, то фиксируется ПРС.
\end{Note}

\begin{Note}[Использование МДК]
    МДК чаще используются как <<внутреннее>> (только на время вычисления) решение: <<снаружи>> программист по-прежнему работает с $n$-разрядными ДК, и обрабатывает ситуации ПРС, о которых ему тем или иным образом сообщает аппаратура (которая скрытно использует МДК!).
\end{Note}

Несомненным достоинством модифицированных кодов является то, что они позволяют судить о ПРС результата, не анализируя знаки исходных операндов. Более того, комбинация знаков $\Number{01}$ говорит о выходе результата за положительную границу диапазона представления, а $\Number{10}$ --- за отрицательную.
    
\begin{Example}
    Используя МДК, выполнить сложение $(85+93)$ в $8$-разрядной сетке.
\end{Example}
\begin{Solve}
    \[
        \Addition{001010101}{001011101}{010110010}
    \]
    Возникло ПРС, так как в старших разрядах МДК-результата --- $\Number{01}$. Программист мог бы обработать такую ситуацию увеличением разрядности данных, например взяв $16$-разрядную сетку и заполнив биты старшего байта значением старшего разряда МДК:
    
    \[
        \Number{00000000 10110010} = 178.
    \]
\end{Solve}
    
\begin{Example}
    Используя МДК, выполнить сложение $(-85)+(-93)$ в $8$-разрядной сетке.
\end{Example}
\begin{Solve}
    \[
        \Addition{110101011}{110100011}{101001110}
    \]
    ПРС --- в старших разрядах МДК-результата комбинация $\Number{10}$. Увеличение разрядности данных до $16$-и разрядов позволит представить результат:
    
    \[
        \Number{11111111 01001110} = \DC{-178}.
    \]
\end{Solve}
\begin{Example}
    Используя МДК, выполнить сложение $(85+(-93))$ в $8$-разрядной сетке.
\end{Example}
\begin{Solve}
    \[
        \Addition{001010101}
                 {110100011}
                 {111111000}
    \]
    
    ПРС нет --- комбинация в старших разрядах $\Number{11}$. Модуль результата: 
    \[\overline{\Number{111111000}} + 1 = \Number{000001000}.\]
    
    Результат: $-8$.
\end{Solve}

В качестве любопытного примера естественности применения дополнительного кода приведем перевод чисел в двоичную систему счисления:
\begin{Example}
    Перевести число $52$ в двоичную систему счисления.
\end{Example}
\begin{Solve}
    \[
        \begin{array}{ll}
            52 = 2\cdot 26 + 0; & \Rightarrow a_0 = 0; \\
            26 = 2\cdot 13 + 0; & \Rightarrow a_1 = 0; \\
            13 = 2\cdot 6 + 1;  & \Rightarrow a_2 = 1; \\
            6  = 2\cdot 3 + 0;  & \Rightarrow a_3 = 0; \\
            3  = 2\cdot 1 + 1;  & \Rightarrow a_4 = 1; \\
            1  = 2\cdot 0 + 1;  & \Rightarrow a_5 = 1; \\
            0  = 2\cdot 0 + 0;  & \Rightarrow a_6 = 0; \\
            0  = 2\cdot 0 + 0;  & \Rightarrow a_7 = 0; \\
            \cdots              & \cdots \\
        \end{array}
    \]
    $52=(\underbrace{0\cdots 0}_{\infty}110100)_2$. Двоичное представление положительлного числа предваряется бесконечной последовательностью нулей.
\end{Solve}

\begin{Example}
    Перевести число ${-52}$ в двоичную систему счисления.
\end{Example}
\begin{Solve}
    \[
        \begin{array}{ll}
            {-52} = 2\cdot {-26} + 0; & \Rightarrow a_0 = 0; \\
            {-26} = 2\cdot {-13} + 0; & \Rightarrow a_1 = 0; \\
            {-13} = 2\cdot {-7} + 1;  & \Rightarrow a_2 = 1; \\
            {-7}  = 2\cdot {-4} + 1;  & \Rightarrow a_3 = 1; \\
            {-4}  = 2\cdot {-2} + 0;  & \Rightarrow a_4 = 0; \\
            {-2}  = 2\cdot {-1} + 0;  & \Rightarrow a_5 = 0; \\
            {-1}  = 2\cdot {-1} + 1;  & \Rightarrow a_6 = 1; \\
            {-1}  = 2\cdot {-1} + 1;  & \Rightarrow a_7 = 1; \\
            \cdots              & \cdots \\
        \end{array}
    \]
    
    Двоичным представлением отрицательного числа является ничто иное, как дополнительный код: ${-52}=(\underbrace{1\cdots 1}_{\infty}001100)_2$ с бесконечной последовательностью ведущих единичных бит.
\end{Solve}


\subsection{Обратный код}

Обратный код отрицательного числа $A$ в $n$-разрядной сетке получается дополнением его модуля до числа $(2^{n}-1)$, то есть 
\[
    (\underbrace{11\cdots 11}_n - |A|)\Leftrightarrow \overline{|A|}.
\]

Обратным кодом положительного числа является двоичное представление его модуля. Таким образом, кодирование числа становится предельно простым:
\[
    \OC{A}=
    \begin{cases}
        \overline{|A|}, & \text{если $A<0$},\\
        |A|,            & \text{если $A\ge 0$}.
    \end{cases}
\]

Извлечение модуля из обратного кода также тривиально:
\[
    |X|=
    \begin{cases}
        \overline{\OC{A}}, & \text{если в знаковом разряде $msb(\OC{A})=1$},\\
        \OC{A},            & \text{если в знаковом разряде $msb(\OC{A})=0$}.
    \end{cases}
\]

\begin{Example}
    Некоторые характерные обратные коды чисел в $n$-разрядной сетке 
    \begin{itemize}
        \item $\OC{-(2^{n-1}-1)}=\underbrace{10\cdots 00}_n$
        \item $\OC{2^{n-1}-1}=\underbrace{01\cdots 11}_n$
        \item $\OC{-2}=\underbrace{11\cdots 101}_n$
        \item $\OC{1}=\underbrace{00\cdots 01}_n$
        \item $\OC{-1}=\underbrace{11\cdots 10}_n$
        \item $\OC{0}=\underbrace{00\cdots 00}_n$
        \item $\OC{0}=\underbrace{11\cdots 11}_n$
    \end{itemize}
\end{Example}

Например, в $8$-разрядной сетке:
\begin{itemize}
    \item \SignedByte{0}{0001010} $\Leftrightarrow$ $10$;
    \item \SignedByte{1}{1110101} $\Leftrightarrow$ ${-10}$;
    \item \SignedByte{0}{1111111} $\Leftrightarrow$ максимум в 8-разрядной сетке: $127$;
    \item \SignedByte{1}{0000000} $\Leftrightarrow$ минимум в 8-разрядной сетке: $-127$;
    \item \SignedByte{0}{0000000} $\Leftrightarrow$ $0$;
    \item \SignedByte{1}{1111111} $\Leftrightarrow$ альтернативный код нуля: ${-0}$; 
\end{itemize}

Из приведенных примеров видно, что нолю в обратном коде соответствуют две кодовых последовательности. Диапазон представления чисел в $n$-разрядном обратном коде меньше, чем в дополнительном:
\begin{equation}
    \label{eq:digitFormat:ocDiapazone}
    \left[-(2^{n-1}-1), (2^{n-1} - 1)\right].
\end{equation}

\begin{Example}
    Найти обратный код числа $-57$ в восьми-разрядной сетке.
\end{Example}
\begin{Solve}
    $|{-57}|=(111001)_2$. В разрядной сетке $|{-57}|$ будет представлено следующим образом:
    \[\UnsignedByte{00111001}\]
    $\OC{-57}$, соответственно равен $\overline{\Number{00111001}}$ или:
    \[\UnsignedByte{11000110}\]
\end{Solve}

При сложении обратных кодов не всегда получается обратный код результата. Могут возникнуть следующие случаи, требующие поправок:

\begin{enumerate}
    \item $A,B\ge 0$
    \[\OC{A}+\OC{B}=|A|+|B|=|A+B|=\OC{A+B}.\]
    
    В этом случае результат представлен в обратном коде верно. Переноса из старшего разряда нет.

    \item $A\ge 0,B<0$
    \[\OC{A}+\OC{B}=|A|+\overline{|B|}=\underbrace{11\cdots 11}_n+(|A|-|B|)\]
    В этом случае возможны два варианта.
    
    \begin{enumerate}
        \item $|A| < |B|$. Должен получиться обратный код отрицательного результата. А результат сложения обратных кодов верен:
        \[
            \underbrace{11\cdots 11}_n - |A+B| = \overline{|A+B|} = \OC{A+B}
        \]
        При этом единицы переноса из старшего разряда суммы не возникает.
        
        \item $|A| \ge |B|$. Должен получиться обратный код положительного результата. Результат же сложения обратных кодов:
        \[
            \underbrace{11\cdots 11}_n + |A+B|
        \]
        
        При этом возникает единица переноса из старшего разряда суммы. Чтобы получить верный результат в обратном коде, к полученному результату нужно прибавить единицу:
        \[
            (\underbrace{11\cdots 11}_n + |A+B|) + 1 = |A+B| = \OC{A+B}
        \]
    \end{enumerate}

    \item $A<0,B\ge 0$. Аналогично предыдущему пункту, достаточно поменять местами слагаемые.
    
    \item $A,B<0$.
    
    \begin{align*}
        \OC{A}+\OC{B}=\overline{|A|}+\overline{|B|}=\underbrace{11\cdots 11}_n+\underbrace{11\cdots 11}_n-|A+B|=\\
        =\underbrace{11\cdots 10}_n - |A+B|.
    \end{align*}
    
    Результат неверен. При этом также возникает единица переноса из старшего разряда суммы. Чтобы получить верный результат в обратном коде к полученному числу нужно прибавить единицу:
    \[
        (\underbrace{11\cdots 10}_n - |A+B|) + 1 = \underbrace{11\cdots 11}_n - |A+B| = \overline{|A+B|} = \OC{A+B}.
    \]
\end{enumerate}

\begin{Note}[Сумма кодов]
    К полученному результату сложения обратных кодов нужно прибавить перенос из старшего разряда суммы. Если выполнять такую коррекцию, то получается правильный обратный код результата.
\end{Note}

О знаке числа, удобно судить по старшему ($msb$) разряду кода: если он равен единице, то число отрицательно, в противном случае --- положительно. Старший разряд обычно называют \emph{знаковым} и выделяют особо, например, $\OC{-52}$ в восьми-разрядной сетке:
\[
    \FixedByte{1}{1001011}
\]

\begin{Example}
    Выполнить вычитание $(52-57)$ в двоичной системе счисления в обратном коде.
\end{Example}
\begin{Solve}
    \[
        \Addition{00110100}
                 {11000110}
                 {11111010}
    \]
    Так как $msb(\Number{11111010})=1$, то представленное число --- отрицательное. Модуль этого числа:
    
    \[|X|=\overline{\Number{11111010}} = \Number{00000101}.\]
    
    Следовательно, результатом является число $-5$.
\end{Solve}

\begin{Example}
    Выполнить вычитание $(57-53)$ в двоичной системе счисления в обратном коде.
\end{Example}
\begin{Solve}
    \[
        \Addition{00111001}
                 {11001010}
                {100000011}
    \]
    
    Единица переноса из старшего разряда прибавляется к младшему разряду результата:
    \[
        \Addition{00000011}
                 {00000001}
                 {00000100}
    \]
    
    Так как $msb(\Number{00000100})=0$, то в коде представлено $+4$.
\end{Solve}

\begin{Note}[Переполнение разрядной сетки]
    ПРС возникает, если складывались операдны одного знака, а результат получился противоположного знака.
\end{Note}

\begin{Example}
    В $8$-разрядной сетке найти результат сложения $85+93$.
\end{Example}
\begin{Solve}
    Согласно формуле \eqref{eq:digitFormat:ocDiapazone} в $8$-разрядной сетке представимы числа из отрезка $[-127,127]$. Сложение кодов дает:
    \[
        \Addition{01010101}
                 {01011101}
                 {10110010}
    \]
    
    Результат в разрядную сетку не умещается и, если не отследить ПРС, то можно зафиксировать неправильный результат: $-77$.
    
    Например, та же самая ситуация, но для отрицательных чисел $(-85)+(-93)$:
    \[
        \Addition{10101010}
                 {10100010}
                {101001100}
    \]
    С поправкой:
    \[
        \Addition{01001100}
                 {00000001}
                 {01001101}
    \]
    
    Не отследив ПРС, можно получить неправильный результат: $+77$.
\end{Solve}

Для контроля ПРС может использоваться модифицированный обратный код.

\begin{Note}[Модифицированный обратный код (МОК)]
    МОК получается из исходного $n$-разрядного ОК добавлением слева разряда, дублирющего знаковый. При сложении $(n+1)$-разрядных МОК, проверяется старшая пара разрядов (знак) результата: если комбинация отличается от $\Number{00}$ и $\Number{11}$, то фиксируется ПРС.
\end{Note}

\begin{Example}
    Используя МОК, выполнить сложение $(-85)+(-93)$ в $8$-разрядной сетке.
\end{Example}
\begin{Solve}
    На время вычислений, исходный 8-разрядный обратный код дополняется до 9-разрядного МОК:
    \[
        \Addition{110101010}
                 {110100010}
                {1101001100}
    \]
    
    С учетом поправки
    \[
        \Addition{101001100}
                 {000000001}
                 {101001101}
    \]
    
    Отрицательное ПРС: в старшей паре разрядов результата  --- комбинация $\Number{10}$. Программист мог бы обработать такую ситуацию увеличением разрядности данных, например взяв $16$-разрядную сетку и заполнив биты старшего байта значением старшего разряда МДК:
    
    \[
        \Number{11111111 01001101} = \OC{-178}.
    \]
\end{Solve}

В заключение можно отметить, что обе комбинации, кодирующие ноль, абсолютно корректно ведут себя при сложении:
\[
    \begin{array}{cc}
            \Addition{01001100}
                     {00000000}
                     {01001100} 
                     & 
                        \Addition{01001100}
                                 {11111111}
                                {101001011} \\
                     & \text{поправка:}\\
                     &
                        \Addition{01001011}
                                 {00000001}
                                 {01001100} 
    \end{array}
\]


\section{Форматы для представления вещественных чисел}

На практике сложились два основных формата представления чисел в вычислительных машинах: 
\begin{itemize}
    \item с фиксированной точкой (запятой);
    \item с плавающей точкой (запятой).
\end{itemize}


\subsection{Фиксированная точка}


Форматы с фиксированной точкой занимают обычно $1$, $2$, $4$ или $8$ байт. В разрядной сетке сохраняется целое двоичное число $A$ в дополнительном коде. При этом заранее договариваются об общем \emph{масштабирующем множителе}
\[M=2^{-n},\] 
на который требуется умножить целое число $A$, чтобы получить исходное вещественное число $X=A\cdot M$. Умножение на $M=2^{-n}$ соответствует переносу точки на $n$ разрядов влево. Таким образом, масштабирующий множитель $M$ \emph{фиксирует} <<воображаемую>> точку между $n$-м и $(n-1)$-м разрядами целочисленного формата.

Чтобы получить представление с фиксированной точкой, нужно умножить исходное вещественное $X$ на ($M^{-1}=2^n$) и отбросить дробную часть (а лучше --- округлить). Дополнительный код получившегося целого числа занести в разрядную сетку.

\begin{Example}
    Представить число $-78.4453125$ в целочисленном формате с фиксированной точкой. Использовать разрядность $16$ бит, масштабирующий множитель $M=2^{-5}$.
\end{Example}
\begin{proof}[Решение]
    Число переводится в двоичную систему счисления точно:
    \[-78.4453125 = (-1001110.0111001)_2 \approx (-\underbrace{0000100111001110}_\text{разрядная сетка}.01)\cdot 2^{-5}.\]
    
    Модуль числа будет выглядеть в заявленной разрядной сетке следующим образом:
    \[
        \FixedTwoBytes{0}{000100111001110}
    \]
    При этом происходит потеря значащих бит дробной части. Отрицательное число представляется в дополнительном коде:
    \[
        \FixedTwoBytes{1}{111011000110010}
    \]
\end{proof}

Рассмотренный подход к представлению вещественных чисел с помощью целых называется целым масштабированием. Большинство языков программирования высокого уровня позволяют работать с целочисленными типами (integer), для представления которых используется формат процессора с фиксированной точкой, очевидно, с масштабом $1=2^0$. 

В теоретических выкладках может оказаться удобнее работать с дробными числами. Предполагается, что точка фиксируется перед старшим разрядом сетки и с помощью масштаба $M=2^n$ переносится на $n$ разрядов вправо. Такое масштабирование называется \emph{дробным}.

\begin{Example}
    Представить число $-78.4453125$ в формате с фиксированной точкой. Использовать разрядность $16$ бит и дробное масштабирование с масштабирующим множителем $M=2^{10}$.
\end{Example}
\begin{proof}[Решение]
    \[-78.4453125 = (-1001110.0111001)_2=(-.\underbrace{0001001110011100}_\text{разрядная сетка}1)\cdot 2^{10}.\]
    
    Модуль, то есть число $78.4453125$, будет выглядеть в заявленном формате следующим образом:
    \[
        \FixedTwoBytes{0}{001001110011100}
    \]
    
    Отрицательное число представляется в дополнительном коде:
    \[
        \FixedTwoBytes{1}{110110001100100}
    \]
\end{proof}

Независимо от способа масштабирования (целое или дробное), компьютер складывает представления по правилам сложения целых чисел (например, в дополнительных кодах), <<не подозревая>> о масштабе. При этом результат сложения будет иметь тот же масштаб, что и операнды.

Оценим погрешность представления в формате с фиксированной точкой, для чего используем целое масштабирование для представления числа $x$ в $n$-разрядной сетке с масштабом $M=2^{-k}$. 

\begin{itemize}
    \item Абсолютная погрешность $\Delta$ --- половина цены деления. Цена деления целочисленного представления $x$: 1. Цена деления $x$ есть $1\cdot M=2^{-k}$.
    \[
        \Delta=\frac{M}{2}=2^{-(k+1)}.
    \]
    
    Абсолютная погрешность в данном формате есть константа.
    
    \item Для относительной погрешности $\delta=\frac{\Delta}{|x|}$ можно оценить диапазон её изменения:
    \begin{align*}
        &\delta_{max}=\frac{\Delta}{|x|_{min}}=\frac{2^{-(k+1)}}{1\cdot M}=\frac{2^{-(k+1)}}{2^{-k}}=\frac{1}{2}, \\
        &\delta_{min}=\frac{\Delta}{|x|_{max}}=\frac{2^{-(k+1)}}{2^{n-1}\cdot M}=\frac{2^{-(k+1)}}{2^{n-1}\cdot 2^{-k}}=\frac{1}{2^n}. 
    \end{align*}
\end{itemize}

Разрядность и масштаб формата с фиксированной точкой выбирается исходя из необходимой абсолютной погрешности.


\subsection{Плавающая точка}

В форматах с плавающей точкой, в системе счисления с основанием $k$, вещественное число $A$ представляется следующим образом\footnote{Мы будем далее работать с двоичной системой счисления, поэтому $k=2$, либо $k=2^n$.}:
\[A=m_A\cdot k^{p_A},\]
где $m_A$ --- \emph{мантисса} числа $A$, а $p_A$ --- \emph{порядок} числа $A$. 

Мантисса $m_A$ обязательно нормализуется! Благодаря нормализации в разрядной сетке мантиссы не хранятся не значащие старшие цифры (ведущие ноли), а сохраняется \emph{максимальное количество значащих цифр} в представлении числа $A$.

Правило нормализации обычно заключается в следующем: порядок числа $p_A$ подбирается так, что мантисса представляет собой дробное число, причём старший разряд дробной части (цифра после точки) есть значащая цифра, а не нуль\footnote{В языках программирования для ввода чисел в \emph{научном} формате используется другое правило нормализации: <<целая часть нормализованной мантиссы представляет собой единственную значащую цифру>>. Например, число $254.76$ будет записано как \verb"2.5476E+2", где \verb"2.5476" --- мантисса, \verb"+2" --- порядок. $254.76=2.5476\cdot 10^{+2}$}. При этом в машинном формате сохраняется конечное количество разрядов дробной части мантиссы. 

Машинный формат с плавающей точкой, представляющий число $A$, можно разделить на две части:
\begin{itemize}
    \item разряды мантиссы $m_A$;
    \item разряды порядка $p_A$.
\end{itemize}

IEEE 754 --- современный стандарт форматов с плавающей точкой. Авторы настоятельно рекомендуют ознакомиться с этим документом\footnote{Чтение стандартов без практического опыта --- обычно бессмысленная трата времени, так как подобные документы сугубо догматичны: они содержат подробное описание технических решений, которые \emph{должны} быть реализованы, но не обосновывают их. Если вам нужны факты --- обращайтесь к стандарту, если знания --- копайте глубже!}. Чтобы облегчить эту задачу, приводимые в данной работе форматы намеренно упрощены, а в следующих разделах выявлены особенности обработки чисел в форматах с плавающей точкой.

\begin{Example}
    \label{ch:digitFormat:16order}
    Определим собственный формат с плавающей точкой. Для представления числа используется шестнадцать двоичных разрядов. И мантисса и порядок представляются в прямом коде. Модуль мантиссы представлен в рязрядах $[15:6]$, знак мантиссы в 15-м разряде. Модуль порядка представлен в разрядах $[5:0]$, знак порядка в $5$-м разряде.
    \[
        \FloatMyHex{X}{XXXXXXXXX}{X}{XXXXX}
    \]
    Представим в таком формате число $-78.4453125$.
\end{Example}
\begin{proof}[Решение]
    Число переводится в двоичную систему счисления точно:
    \[-78.4453125 = (-1001110.0111001)_2.\]
    
    Нормализуется двоичное представление мантиссы:
    \[-78.4453125 = (-0.10011100111001)_2\cdot 2^{(+111)_2}.\]
    
    Результат:
    \[
        \FloatMyHex{1}{100111001}{0}{00111}
    \]
    
    Следует обратить внимание на то, что старший разряд модуля мантиссы для любого ненулевого числа \emph{всегда} будет равен $1$. Также следует обратить внимание на потерю точности представления: на самом деле в формате представлено число $-78.25$.
\end{proof}

В машинных форматах, применяемых на практике, вместо порядка используют \emph{смещённый} порядок --- \emph{характеристику}. В отличие от порядка, характеристика --- всегда положительное число. Чтобы получить характеристику $c_A$ числа $A$, нужно к его порядку прибавить фиксированную константу $\Delta$ --- смещение:
\[
    c_A = p_A + \Delta.
\]

Тогда число, представленное в формате, будет определяться следующим образом: 
\[
    A=m_A\cdot k^{(c_A - \Delta)}.
\]
    
Смещение $\Delta$ выбирается исходя из количества разрядов, отведенных под представлние порядка (а также и характеристики). Допустим, что под представление порядка отведено $n$ двоичных разрядов. Известно, что в $n$ разрядах можно представить любое натуральное число из диапазона $[0,2^n-1]$. Так как порядок может быть и отрицательным, то придется пожертвовать одним разрядом под знак. 

Если использовать дополнительный код, то диапазон представления будет следующим: 
\[
    [-2^{n-1},(2^{n-1}-1)].
\]

В случае использования прямого или обратного кодов, диапазон сокращается из-за того, что положительный и отрицательный ноль кодируются разными кодами:
\[
    [-(2^{n-1}-1),(2^{n-1}-1)].
\]

Таким образом, смещение $\Delta$ для получения характеристики выбирается так, чтобы при сложении с наибольшим по модулю отрицательным числом диапазона представления порядка получался ноль.

В случае использования дополнительного кода, очевидно, что $\Delta = 2^{n-1}$. В двоичном представлении $\Delta$ --- число с единственной единицей в знаковом (самом старшем) разряде. Такая поправка, прибавленная к дополнительному коду порядка, приводит к инверсии старшего (знакового) разряда.
\begin{Example}
    \label{ch:digitFormat:16char}
    Определим собственный формат с плавающей точкой. Для представления числа используется шестнадцать двоичных разрядов. Мантисса представляется в прямом коде. Модуль мантиссы представлен в разрядах $[15:6]$, знак мантиссы в $15$-м разряде. Характеристика представлена в разрядах $[5:0]$, смещение порядка $\Delta=2^5$
    \[
        \FloatMyCharHex{X}{XXXXXXXXX}{XXXXXX}
    \]
    Представим в таком формате число $A=-0.0859375$.
\end{Example}
\begin{proof}[Решение]
    Число переводится в двоичную систему счисления точно:
    \[-0.0859375 = (-0.0001011)_2.\]
    
    Нормализуеется двоичное представление мантиссы:
    \[-0.0859375 = (-0.1011)_2\cdot 2^{(-11)_2}.\]
    
    Порядок $p_A=-3$, характеристика $c_A={-3}+2^5=29=(11101)_2$.
    Результат:
    \[
        \FloatMyCharHex{1}{101100000}{011101}
    \]
    
    Следует еще раз обратить внимание на то, что дополнительный код порядка \DC{-3}=\Number{111101} от получившейся характеристики отличается лишь знаковым разрядом.
\end{proof}

Использование характеристики вместо порядка дает на практике несколько преимуществ, одно из которых заключается в том, что положительные числа (характеристики) гораздо проще сравнивать друг с другом.

\begin{Example}
    \label{ch:digitFormat:16DcMantChar}
    Определим собственный формат с плавающей точкой. Для представления числа используется шестнадцать двоичных разрядов. Мантисса представляется в дополнительном коде, который размещается в разрядах $[15:6]$, знаковым разрядом мантиссы следует считать $15$-й разряд. Характеристика представлена в разрядах $[5:0]$, смещение порядка $\Delta=2^5$.
    \[
        \FloatMyDcMantCharHex{XXXXXXXXXX}{XXXXXX}
    \]
    Представим в формате различные числа.
\end{Example}
\begin{proof}[Решение]
    В двоичном дополнительном коде отрицательного числа не значащими цифрами являются ведущие единицы, а положительного --- ведущие нули.
    
    Пусть мантисса числа уже представлена в дополнительном коде. Для её нормализации в разрядной сетке требуется выбрать порядок так, чтобы после точки шла не значащая цифра, следом за которой должна идти значащая. Так как эти цифры всегда будут отличаться, то признаком нормализованной мантиссы в дополнительном коде будут комбинации \Machine{01} и \Machine{10} в её старших разрядах.
    
    Допустим, требуется представить число $-5$:
    \[\DC{-(\cdots 0101.0\cdots)_2}=(\cdots 1011.0 \cdots)=(\cdots 1.\underbrace{10110 \cdots}_{m_A})\cdot 2^4.\]
    
    Тогда $-5$:
    \[
        \FloatMyDcMantCharHex{1011000000}{100100}
    \]
    Приведём еще несколько примеров:
    \begin{center}
        \begin{tabular}{ccc}
            $5$ & $=$
                &
                \raisebox{.5\height}{
                    \FloatMyDcMantCharHex{0101000000}{100100}
                } \\
            $-0.5$ & $=$
                &
                \raisebox{.5\height}{
                    \FloatMyDcMantCharHex{1000000000}{100000}
                } \\
            $0.5$ & $=$
                &
                \raisebox{.5\height}{
                    \FloatMyDcMantCharHex{0100000000}{100001}
                } \\
            $-2$ & $=$
                &
                \raisebox{.5\height}{
                    \FloatMyDcMantCharHex{1000000000}{100010}
                } \\
            $2$ & $=$
                &
                \raisebox{.5\height}{
                    \FloatMyDcMantCharHex{0100000000}{100011}
                } \\
            $-27$ & $=$
                &
                \raisebox{.5\height}{
                    \FloatMyDcMantCharHex{1001010000}{100110}
                } \\
        \end{tabular}
    \end{center}
\end{proof}

Опишем несколько форматов, использовавшихся в прошлом.
\begin{itemize}
    \item ЕС ЭВМ. Используется три варианта формата: короткий (32 бита), длинный (64 бита), расширенный (128 бит). Во всех вариантах используются смещённые порядки (характеристики), занимающие 7 бит (смещение $\Delta = 64$). Старший бит формата содержит знак числа, затем следуют 7 бит характеристики, а оставшиеся разряды занимает модуль мантиссы. Мантисса изображается в двоично-кодированной 16-ичной системе счисления, т.е. каждые 4 бита двоичной мантиссы воспринимаются ЭВМ как шестнадцатеричная цифра. Т.е. \[A=m_A\cdot 16^{(c_A-\Delta)}.\] Мантисса нормализуется так, что после точки (запятой) следует ненулевая шестнадцатеричная цифра, а её целая часть равна нолю.
    
    Например, число $-5.75=(101.11)_2$ в таком формате будет представлено как $0.010111\cdot 16^{1}$:
    \[
        \FloatESShort{1}{1000001}{0101 1100 0000 0000 0000 0000}
    \]
    
    \item СМ ЭВМ. Также используется два варианта формата: короткий (32 бита) и длинный (64 бита). Характеристика в обоих вариантах занимает 8 бит ($\Delta = 128$). Старший разряд отводится под знак числа, далее следуют 8 бит характеристики, а остальные разряды занимает модуль мантиссы. Характеристика отражает положение точки в двоичном представлении числа:
    \[A=m_A\cdot 2^{(c_A-\Delta)}.\]
    
    Например, число $-5.75=(101.11)_2$ в таком формате будет представлено как $0.10111\cdot 2^{3}$:
    \[
        \FloatPCShort{1}{10000011}{10111000000000000000000}
    \]
\end{itemize}

Оценим погрешность представления $x = \FloatExpression{x}{2}$ в формате с плавающей точкой:
    
\begin{itemize}
    \item Абсолютная погрешность зависит от порядка числа:
    \[
        \Delta=
            \frac{2^{-\lVert\MantissOf{x}\rVert}}{2}\cdot 2^{\OrderOf{x}}=
            \frac{2^{(\OrderOf{x} - \lVert\MantissOf{x}\rVert)}}
                 {2},
    \]
    где $\lVert\MantissOf{x}\rVert$ --- количество разрядов мантиссы.
    
    Видно, что чем больше порядок числа, тем больше абсолютная погрешность, причем величина погрешности растет экспоненциально.
    
    \item Для относительной погрешности $\delta=\frac{\Delta}{|x|}$ оценим диапазон, который, как видно, от порядка числа не зависит.
    \begin{align*}
        &\delta_{max}=\frac{\Delta}{2^{-1}\cdot 2^{\OrderOf{x}}}=
            2^{-\lVert\MantissOf{x}\rVert},
        \\            
        &\delta_{min}=
            \frac{\Delta}
                 {(1-2^{-\lVert\MantissOf{x}\rVert})\cdot 2^{\OrderOf{x}}}= 
            \frac{2^{- \lVert\MantissOf{x}\rVert}}
                 {2\cdot(1-2^{-\lVert\MantissOf{x}\rVert})}\approx 
                 \frac{2^{-\lVert\MantissOf{x}\rVert}}{2}.
    \end{align*}
    Можно считать, что относительная погрешность в формате с плавающей точкой --- константа, равная вкладу младшего разряда мантиссы.
\end{itemize}

Разрядности мантиссы и порядка формата с плавающей точкой выбираются исходя из необходимой относительной погрешности.

Современные форматы с плавающей точкой определены стандартом института инженеров электротехники и электроники IEEE 754, краткое их описание можно найти в \cite{bib:zubkov:asm}.